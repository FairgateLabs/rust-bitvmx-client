use anyhow::{Ok, Result};
use bitcoin::hashes::{sha256d, Hash, HashEngine};
use bitcoin::hex::Case;
use bitcoin::hex::DisplayHex;
use bitcoin::Transaction;
use bitcoin::Txid;
use bitcoin_coordinator::types::FullBlock;

#[derive(Debug)]
pub struct MerkleBranch {
    hashes: Vec<[u8; 32]>,
    path: u32,
}

pub struct BtcTxSPVProof {
    pub block_hash: String,
    pub tx: Transaction,
    pub merkle_branch_path: String,
    pub merkle_branch_hashes: Vec<[u8; 32]>,
}

pub fn get_merkle_branch(txid: Txid, block_info: FullBlock) -> Result<BtcTxSPVProof> {
    // Get block transactions and find our tx index
    let (tx, tx_index) = block_info
        .txs
        .iter()
        .enumerate()
        .find_map(|(i, t)| {
            if t.compute_txid() == txid {
                Some((t.clone(), i))
            } else {
                None
            }
        })
        .ok_or_else(|| anyhow::anyhow!("Transaction not found in block"))?;

    // Build the complete merkle tree with hashes in bitcoin endianes
    let merkle_tree = build_merkle_tree_store(&block_info.txs, false);

    // Build the merkle branch with hashes in pc endianes
    let branch = build_merkle_branch(&merkle_tree, block_info.txs.len() as u32, tx_index as u32);
    println!(
        "Merkle Tree Root: {:#?}",
        get_merkle_tree_root_hex(&merkle_tree)
    );
    println!("Merkle Branch Path: {:#?}", branch.path);
    println!(
        "Merkle Branch Hashes {:#?}",
        branch
            .hashes
            .iter()
            .map(|f| format!("0x{}", f.to_hex_string(Case::Lower)))
            .collect::<Vec<String>>()
    );
    Ok(BtcTxSPVProof {
        block_hash: block_info.hash.to_string(),
        tx,
        merkle_branch_path: branch.path.to_string(),
        merkle_branch_hashes: branch.hashes,
    })
}

fn to_swapped_bytes32(hash: &[u8; 32]) -> [u8; 32] {
    let mut swapped = [0u8; 32];
    for i in 0..16 {
        swapped[i] = hash[31 - i];
        swapped[31 - i] = hash[i];
    }
    swapped
}

fn next_power_of_two(n: usize) -> usize {
    // Return the number if it's already a power of 2
    if n & (n - 1) == 0 {
        return n;
    }

    // Calculate next power of two using log2 and bit shifting
    let exponent = (usize::BITS - n.leading_zeros()) as usize;
    return 1 << exponent; // 2^exponent
}

fn hash_merkle_branches(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    let mut engine = sha256d::Hash::engine();
    engine.input(left);
    engine.input(right);
    sha256d::Hash::from_engine(engine).to_byte_array()
}

// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,
// stores it using a linear array, and returns a slice of the backing array.  A
// linear array was chosen as opposed to an actual tree structure since it uses
// about half as much memory.  The following describes a merkle tree and how it
// is stored in a linear array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for bitcoin transactions
// where h(x) is a double sha256 follows:
//
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
//
//	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// See https://github.com/btcsuite/btcd/blob/master/blockchain/merkle.go#L74
fn build_merkle_tree_store(txs: &[Transaction], witness: bool) -> Vec<Option<[u8; 32]>> {
    // Calculate array size for the complete binary tree
    let next_pot = next_power_of_two(txs.len());
    let array_size = next_pot * 2 - 1;
    let mut merkles = vec![None; array_size];

    // Create the base transaction hashes
    for (i, tx) in txs.iter().enumerate() {
        merkles[i] = Some(if witness && i == 0 {
            // For witness merkle root, coinbase wtxid is all zeroes
            [0u8; 32]
        } else if witness {
            // For witness merkle root, use witness hash
            tx.compute_wtxid().to_byte_array()
        } else {
            // Regular merkle root uses txid
            tx.compute_txid().to_byte_array()
        });
    }

    // Start the array offset after the last transaction and adjusted to the next power of two
    let mut offset = next_pot;
    for i in (0..array_size - 1).step_by(2) {
        merkles[offset] = match (merkles[i], merkles[i + 1]) {
            // When there is no left child node, the parent is None too
            (None, _) => None,

            // When there is no right child, the parent is generated by
            // hashing the concatenation of the left child with itself
            (Some(left), None) => Some(hash_merkle_branches(&left, &left)),

            // The normal case sets the parent node to the double sha256
            // of the concatenation of the left and right children
            (Some(left), Some(right)) => Some(hash_merkle_branches(&left, &right)),
        };
        offset += 1;
    }

    merkles
}

fn build_merkle_branch(
    merkle_tree: &Vec<Option<[u8; 32]>>,
    tx_count: u32,
    tx_index: u32,
) -> MerkleBranch {
    let mut hashes = Vec::new();
    let mut path = 0;
    let mut path_index = 0;
    let mut level_offset = 0;
    let mut current_node_offset = tx_index;

    // Create a clean store without nil values
    let clean_merkle_tree: Vec<[u8; 32]> = merkle_tree.iter().filter_map(|node| *node).collect();

    let mut level_size = tx_count;
    while level_size > 1 {
        let target_offset;
        if current_node_offset % 2 == 0 {
            // Target is left hand side, use right hand side
            target_offset = std::cmp::min(current_node_offset + 1, level_size - 1)
        } else {
            // Target is right hand side, use left hand side
            target_offset = current_node_offset - 1;
            path += 1 << path_index;
        };

        let hash = clean_merkle_tree
            .get((level_offset + target_offset) as usize)
            .unwrap();
        hashes.push(to_swapped_bytes32(hash));

        level_offset += level_size;
        current_node_offset /= 2;
        path_index += 1;
        level_size = (level_size + 1) / 2;
    }

    MerkleBranch { hashes, path }
}

fn get_merkle_tree_root_hex(merkle_tree: &Vec<Option<[u8; 32]>>) -> String {
    return to_swapped_bytes32(&merkle_tree.last().unwrap().unwrap()).to_hex_string(Case::Lower);
}

#[cfg(test)]
mod tests {

    use std::str::FromStr;

    use super::*;
    use bitcoin::consensus::Decodable;
    use bitcoin::hex::Case;
    use bitcoin::hex::DisplayHex;

    #[test]
    fn test_hash_merkle_branches() {
        // Example from https://learnmeabitcoin.com/technical/block/merkle-root/#structure
        let txids = [
            Txid::from_str("8c14f0db3df150123e6f3dbbf30f8b955a8249b62ac1d1ff16284aefa3d06d87")
                .unwrap()
                .to_byte_array(),
            Txid::from_str("fff2525b8931402dd09222c50775608f75787bd2b87e56995a7bdd30f79702c4")
                .unwrap()
                .to_byte_array(),
            Txid::from_str("6359f0868171b1d194cbee1af2f16ea598ae8fad666d9b012c8ed2b79a236ec4")
                .unwrap()
                .to_byte_array(),
            Txid::from_str("e9a66845e05d5abc0ad04ec80f774a7e585c6e8db975962d069a522137b80c1d")
                .unwrap()
                .to_byte_array(),
        ];

        let branch_a = hash_merkle_branches(&txids[0], &txids[1]);
        let branch_b = hash_merkle_branches(&txids[2], &txids[3]);
        let merkle_root = hash_merkle_branches(&branch_a, &branch_b);
        assert_eq!(
            to_swapped_bytes32(&merkle_root).to_hex_string(Case::Lower),
            "f3e94742aca4b5ef85488dc37c06c3282295ffec960994b2c0d5ac2a25a95766",
            "Merkle root is wrong"
        );
    }

    #[test]
    fn test_build_merkle_tree_store_and_branches() {
        // Arrenge
        // From https://mempool.space/es/block/000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506
        let txids = [
            // 8c14f0db3df150123e6f3dbbf30f8b955a8249b62ac1d1ff16284aefa3d06d87
            Transaction::consensus_decode(&mut hex::decode("01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff08044c86041b020602ffffffff0100f2052a010000004341041b0e8c2567c12536aa13357b79a073dc4444acb83c4ec7a0e2f99dd7457516c5817242da796924ca4e99947d087fedf9ce467cb9f7c6287078f801df276fdf84ac00000000").unwrap().as_slice()).unwrap(),
            // fff2525b8931402dd09222c50775608f75787bd2b87e56995a7bdd30f79702c4
            Transaction::consensus_decode(&mut hex::decode("0100000001032e38e9c0a84c6046d687d10556dcacc41d275ec55fc00779ac88fdf357a187000000008c493046022100c352d3dd993a981beba4a63ad15c209275ca9470abfcd57da93b58e4eb5dce82022100840792bc1f456062819f15d33ee7055cf7b5ee1af1ebcc6028d9cdb1c3af7748014104f46db5e9d61a9dc27b8d64ad23e7383a4e6ca164593c2527c038c0857eb67ee8e825dca65046b82c9331586c82e0fd1f633f25f87c161bc6f8a630121df2b3d3ffffffff0200e32321000000001976a914c398efa9c392ba6013c5e04ee729755ef7f58b3288ac000fe208010000001976a914948c765a6914d43f2a7ac177da2c2f6b52de3d7c88ac00000000").unwrap().as_slice()).unwrap(),
            // 6359f0868171b1d194cbee1af2f16ea598ae8fad666d9b012c8ed2b79a236ec4
            Transaction::consensus_decode(&mut hex::decode("0100000001c33ebff2a709f13d9f9a7569ab16a32786af7d7e2de09265e41c61d078294ecf010000008a4730440220032d30df5ee6f57fa46cddb5eb8d0d9fe8de6b342d27942ae90a3231e0ba333e02203deee8060fdc70230a7f5b4ad7d7bc3e628cbe219a886b84269eaeb81e26b4fe014104ae31c31bf91278d99b8377a35bbce5b27d9fff15456839e919453fc7b3f721f0ba403ff96c9deeb680e5fd341c0fc3a7b90da4631ee39560639db462e9cb850fffffffff0240420f00000000001976a914b0dcbf97eabf4404e31d952477ce822dadbe7e1088acc060d211000000001976a9146b1281eec25ab4e1e0793ff4e08ab1abb3409cd988ac00000000").unwrap().as_slice()).unwrap(),
            // e9a66845e05d5abc0ad04ec80f774a7e585c6e8db975962d069a522137b80c1d
            Transaction::consensus_decode(&mut hex::decode("01000000010b6072b386d4a773235237f64c1126ac3b240c84b917a3909ba1c43ded5f51f4000000008c493046022100bb1ad26df930a51cce110cf44f7a48c3c561fd977500b1ae5d6b6fd13d0b3f4a022100c5b42951acedff14abba2736fd574bdb465f3e6f8da12e2c5303954aca7f78f3014104a7135bfe824c97ecc01ec7d7e336185c81e2aa2c41ab175407c09484ce9694b44953fcb751206564a9c24dd094d42fdbfdd5aad3e063ce6af4cfaaea4ea14fbbffffffff0140420f00000000001976a91439aa3d569e06a1d7926dc4be1193c99bf2eb9ee088ac00000000").unwrap().as_slice()).unwrap(),
        ];
        let tx_index = 2;

        // Act
        let merkle_tree = build_merkle_tree_store(&txids, false);
        let branch = build_merkle_branch(&merkle_tree, txids.len() as u32, tx_index as u32);

        // Assert
        assert_eq!(
            branch.hashes.len(),
            2,
            "Merkle Branch Path has wrong number of hashes"
        );
        assert_eq!(branch.path, tx_index, "Merkle Branch Path is wrong");
        let expected_merkle_root =
            "f3e94742aca4b5ef85488dc37c06c3282295ffec960994b2c0d5ac2a25a95766";
        assert_eq!(
            get_merkle_tree_root_hex(&merkle_tree),
            expected_merkle_root,
            "Merkle root is wrong"
        );
        let step_1 = hash_merkle_branches(
            &merkle_tree[tx_index as usize].unwrap(),
            &to_swapped_bytes32(&branch.hashes[0]),
        );
        let branch_root = hash_merkle_branches(&to_swapped_bytes32(&branch.hashes[1]), &step_1);
        assert_eq!(
            to_swapped_bytes32(&branch_root).to_hex_string(Case::Lower),
            expected_merkle_root,
            "Merkle branch root is wrong"
        );
    }

    #[test]
    fn test_build_merkle_tree_store_and_branches_multiple_levels() {
        // Arrenge
        // From https://www.blockchain.com/explorer/blocks/btc/100001
        let txids = [
            // bb28a1a5b3a02e7657a81c38355d56c6f05e80b9219432e3352ddcfc3cb6304c
            Transaction::consensus_decode(&mut hex::decode("01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff07044c86041b010dffffffff0100f2052a01000000434104b27f7e9475ccf5d9a431cb86d665b8302c140144ec2397fce792f4a4e7765fecf8128534eaa71df04f93c74676ae8279195128a1506ebf7379d23dab8fca0f63ac00000000").unwrap().as_slice()).unwrap(),
            // fbde5d03b027d2b9ba4cf5d4fecab9a99864df2637b25ea4cbcb1796ff6550ca
            Transaction::consensus_decode(&mut hex::decode("0100000001d992e5a888a86d4c7a6a69167a4728ee69497509740fc5f456a24528c340219a000000008b483045022100f0519bdc9282ff476da1323b8ef7ffe33f495c1a8d52cc522b437022d83f6a230220159b61d197fbae01b4a66622a23bc3f1def65d5fa24efd5c26fa872f3a246b8e014104839f9023296a1fabb133140128ca2709f6818c7d099491690bd8ac0fd55279def6a2ceb6ab7b5e4a71889b6e739f09509565eec789e86886f6f936fa42097adeffffffff02000fe208010000001976a914948c765a6914d43f2a7ac177da2c2f6b52de3d7c88ac00e32321000000001976a9140c34f4e29ab5a615d5ea28d4817f12b137d62ed588ac00000000").unwrap().as_slice()).unwrap(),
            // 8131ffb0a2c945ecaf9b9063e59558784f9c3a74741ce6ae2a18d0571dac15bb
            Transaction::consensus_decode(&mut hex::decode("01000000059daf0abe7a92618546a9dbcfd65869b6178c66ec21ccfda878c1175979cfd9ef000000004a493046022100c2f7f25be5de6ce88ac3c1a519514379e91f39b31ddff279a3db0b1a229b708b022100b29efbdbd9837cc6a6c7318aa4900ed7e4d65662c34d1622a2035a3a5534a99a01ffffffffd516330ebdf075948da56db13d22632a4fb941122df2884397dda45d451acefb0000000048473044022051243debe6d4f2b433bee0cee78c5c4073ead0e3bde54296dbed6176e128659c022044417bfe16f44eb7b6eb0cdf077b9ce972a332e15395c09ca5e4f602958d266101ffffffffe1f5aa33961227b3c344e57179417ce01b7ccd421117fe2336289b70489883f900000000484730440220593252bb992ce3c85baf28d6e3aa32065816271d2c822398fe7ee28a856bc943022066d429dd5025d3c86fd8fd8a58e183a844bd94aa312cefe00388f57c85b0ca3201ffffffffe207e83718129505e6a7484831442f668164ae659fddb82e9e5421a081fb90d50000000049483045022067cf27eb733e5bcae412a586b25a74417c237161a084167c2a0b439abfebdcb2022100efcc6baa6824b4c5205aa967e0b76d31abf89e738d4b6b014e788c9a8cccaf0c01ffffffffe23b8d9d80a9e9d977fab3c94dbe37befee63822443c3ec5ae5a713ede66c3940000000049483045022020f2eb35036666b1debe0d1d2e77a36d5d9c4e96c1dba23f5100f193dbf524790221008ce79bc1321fb4357c6daee818038d41544749127751726e46b2b320c8b565a201ffffffff0200ba1dd2050000001976a914366a27645806e817a6cd40bc869bdad92fe5509188ac40420f00000000001976a914ee8bd501094a7d5ca318da2506de35e1cb025ddc88ac00000000").unwrap().as_slice()).unwrap(),
            // d6c7cb254aa7a5fd446e8b48c307890a2d4e426da8ad2e1191cc1d8bbe0677d7
            Transaction::consensus_decode(&mut hex::decode("01000000010abad2dc0c9b4b1dbb023077da513f81e5a71788d8680fca98ef1c37356c459c000000004a493046022100a894e521c87b3dbe23007079db4ac2896e9e791f8b57317ba6c0d99a7becd27a022100bc40981393eafeb33e89079f857c728701a9af4523c3f857cd96a500f240780901ffffffff024026ee22010000001976a914d28f9cefb58c1f7a5f97aa6b79047585f58fbd4388acc0cb1707000000001976a9142229481696e417aa5f51ad751d8cd4c6a669e4fe88ac00000000").unwrap().as_slice()).unwrap(),
            // ce29e5407f5e4c9ad581c337a639f3041b24220d5aa60370d96a39335538810b
            Transaction::consensus_decode(&mut hex::decode("0100000001f66d89b3649e0b18d84db056930676cb81c0168042fc4324c3682e252ea9410d0000000048473044022038e0b55b37c9253bfeda59c76c0134530f91fb586d6eb21738a77a984f370a44022048d4d477aaf97ef9c8275bbc5cb19b9c8a0e9b1f9fdafdd39bc85bf6c2f04a4d01ffffffff024041a523010000001976a914955f70ac8792b48b7bd52b15413bd8500ecf32c888ac00f36f06000000001976a91486116d15f3dbb23a2b58346f36e6ec2d867eba2b88ac00000000").unwrap().as_slice()).unwrap(),
            // 45a38677e1be28bd38b51bc1a1c0280055375cdf54472e04c590a989ead82515
            Transaction::consensus_decode(&mut hex::decode("010000000126c384984f63446a4f2be8dd6531ba9837bd5f2c3d37403c5f51fb9192ee754e010000008b48304502210083af8324456f052ff1b2597ff0e6a8cce8b006e379a410cf781be7874a2691c2022072259e2f7292960dea0ffc361bbad0b861f719beb8550476f22ce0f82c023449014104f3ed46a81cba02af0593e8572a9130adb0d348b538c829ccaaf8e6075b78439b2746a76891ce7ba71abbcbb7ca76e8a220782738a6789562827c1065b0ce911dffffffff02c0dd9107000000001976a91463d4dd1b29d95ed601512b487bfc1c49d84d057988ac00a0491a010000001976a91465746bef92511df7b34abf71c162efb7ae353de388ac00000000").unwrap().as_slice()).unwrap(),
            // c5abc61566dbb1c4bce5e1fda7b66bed22eb2130cea4b721690bc1488465abc9
            Transaction::consensus_decode(&mut hex::decode("01000000011b56cf3aab3286d582c055a42af3a911ee08423f276da702bb67f1222ac1a5b6000000008c4930460221009e9fba682e162c9627b96b7df272006a727988680b956c61baff869f0907b8fb022100a9c19adc7c36144bafe526630783845e5cb9554d30d3edfb56f0740274d507f30141046e0efbfac7b1615ad553a6f097615bc63b7cdb3b8e1cb3263b619ba63740012f51c7c5b09390e3577e377b7537e61226e315f95f926444fc5e5f2978c112e448ffffffff02c0072b11010000001976a914b73e9e01933351ca076faf8e0d94dd58079d0b1f88ac80b63908000000001976a9141aca0bdf0d2cee63db19aa4a484f45a4e26a880c88ac00000000").unwrap().as_slice()).unwrap(),
            // a71f74ab78b564004fffedb2357fb4059ddfc629cb29ceeb449fafbf272104ca
            Transaction::consensus_decode(&mut hex::decode("0100000001251b187504ea873b2c3915fad401f7a7734cc13567e0417708e86294a29f4f68010000008b4830450221009bef423141ed1ae60d0a5bcaa57b1673fc96001f0d4e105535cca817ba5a7724022037c399bd30374f22481ffc81327cfca4951c7264b227f765fcd6a429f3d9d2080141044d0d1b4f194c31a73dbce41c42b4b3946849117c5bb320467e014bad3b1532f28a9a1568ba7108f188e7823b6e618e91d974306701379a27b9339e646e156e7bffffffff02c00fd103010000001976a914ef7f5d9e1bc6ed68cfe0b1db9d8f09cef0f3ba4a88ac004dd208000000001976a914c22420641cea028c9e06c4d9104c1646f8b1769088ac00000000").unwrap().as_slice()).unwrap(),
            // fda204502a3345e08afd6af27377c052e77f1fefeaeb31bdd45f1e1237ca5470
            Transaction::consensus_decode(&mut hex::decode("01000000013486dd5f0a2f3efcc04f64cb03872c021f98ee39f514747ce5336b874bbe47a7010000008b48304502201cadddc2838598fee7dc35a12b340c6bde8b389f7bfd19a1252a17c4b5ed2d71022100c1a251bbecb14b058a8bd77f65de87e51c47e95904f4c0e9d52eddc21c1415ac014104fe7df86d58aafa9246ca6fd30c905714533c25f700e2329b8ecec8aa52083b844baa3a8acd5d6b9732dcb39079bb56ba2711a3580dec824955fce0596a460c11ffffffff02c011f6e1000000001976a91490fac83c9adde91d670dde8755f8b475ab9e427d88acc0f9df15000000001976a91437f691b3e8ee5dcb56c2e31af4c80caa2df3b09b88ac00000000").unwrap().as_slice()).unwrap(),
            // d3cd1ee6655097146bdae1c177eb251de92aed9045a0959edc6b91d7d8c1f158
            Transaction::consensus_decode(&mut hex::decode("010000000170016bd1274b795b262f32a53003a4714b22b62f9057adf5fbe6ed939003b5190100000089463043022061456499582170a94d6b54308f792e37dad28bf0ed7aa61021f0301d2774d378021f4224b33f707efd810a01dd34ea86d6069cd599cc435513a0eef8c83c137bf7014104a2c95d6b98e745448eb45ed0ba95cf24dd7c3b16386e1028e24a0358ee4afc33e2f0199139853edaf32845d8a42254c75f7dc8add3286c682c650fbd93f0a4a1ffffffff02001bd2b7000000001976a9141b11c6acaa5223013f3a3240fdb024ecd9f8135488ac8023ad18000000001976a914ada27ca87bbaa1ee6fb1cb61bb0a29baaf6da2c988ac00000000").unwrap().as_slice()).unwrap(),
            // cb00f8a0573b18faa8c4f467b049f5d202bf1101d9ef2633bc611be70376a4b4
            Transaction::consensus_decode(&mut hex::decode("0100000001c8ff91f031ec6a5aba4baee6549e61dd01f26f61b70e2f1574f24cd680f464ad000000008b48304502210082235e21a2300022738dabb8e1bbd9d19cfb1e7ab8c30a23b0afbb8d178abcf3022024bf68e256c534ddfaf966bf908deb944305596f7bdcc38d69acad7f9c868724014104174f9eef1157dc1ad5eac198250b70d1c3b04b2fca12ad1483f07358486f02909b088bbc83f4de55f767f6cdf9d424aa02b5eeaffa08394d39b717895fc08d0affffffff0200ea3b43000000001976a914fb32df708f0610901f6d1b6df8c9c368fe0d981c88ac800f1777000000001976a914462c501c70fb996d15ac0771e7fc8d3ca3f7201888ac00000000").unwrap().as_slice()).unwrap(),
            // 05d07bb2de2bda1115409f99bf6b626d23ecb6bed810d8be263352988e4548cb
            Transaction::consensus_decode(&mut hex::decode("0100000001c67323867de802402e780a70e0deba3c708c4d87497e17590afee9c321f1c680010000008a473044022042734b25f54845d662e6499b75ff8529ff47f42fd224498a9f752d212326dbfa0220523e4b7b570bbb1f3af02baa2c04ea8eb7b0fccb1522cced130b666ae9a9d014014104b5a23b922949877e9eaf7512897ed091958e2e8cf05b0d0eb9064e7976043fde6023b4e2c188b7e38ef94eec6845dc4933f5e8635f1f6a3702290956aa9e284bffffffff0280041838030000001976a91436e5884215f7d3044be5d37bdd8c987d9d942c8488ac404b4c00000000001976a91460085d6838f8a44a21a0de56ff963cfa6242a96188ac00000000").unwrap().as_slice()).unwrap(),
        ];
        let tx_index = 9;

        // Act
        let merkle_tree = build_merkle_tree_store(&txids, false);

        println!(
            "merkle_tree: {:#?}",
            merkle_tree
                .iter()
                .map(|h| match h {
                    Some(hash) => to_swapped_bytes32(hash).to_hex_string(Case::Lower),
                    None => String::new(),
                })
                .collect::<Vec<String>>()
        );
        let branch = build_merkle_branch(&merkle_tree, txids.len() as u32, tx_index as u32);

        // Assert
        println!(
            "Merkle Branch Hashes {:#?}",
            branch
                .hashes
                .iter()
                .map(|f| f.to_hex_string(Case::Lower))
                .collect::<Vec<String>>()
        );
        assert_eq!(
            branch.hashes.len(),
            4,
            "Merkle Branch Path has wrong number of hashes"
        );
        assert_eq!(branch.path, tx_index, "Merkle Branch Path is wrong");
        assert_eq!(
            get_merkle_tree_root_hex(&merkle_tree),
            "7fe79307aeb300d910d9c4bec5bacb4c7e114c7dfd6789e19f3a733debb3bb6a",
            "Merkle root is wrong"
        );
        assert_eq!(
            branch.hashes[0].to_hex_string(Case::Lower),
            "fda204502a3345e08afd6af27377c052e77f1fefeaeb31bdd45f1e1237ca5470"
        );
        assert_eq!(
            branch.hashes[1].to_hex_string(Case::Lower),
            "4cae7afef85647a85243690c03b14e046b4fd5bc34f74ef3c0c42d5e88397142"
        );
        assert_eq!(
            branch.hashes[2].to_hex_string(Case::Lower),
            "7b887d0f29b0076533340c3736b20169f2fce65965c558d5178c500359a79129"
        );
        assert_eq!(
            branch.hashes[3].to_hex_string(Case::Lower),
            "72d984fc9a028a71d1a58029c67797c1f39c48888ffe28f7e19a3069e4ec7e99"
        );
    }

    #[test]
    fn test_to_swapped_bytes32() {
        let bytes_to_reverse: [u8; 32] =
            hex::decode("6657a9252aacd5c0b2940996ecff952228c3067cc38d4885efb5a4ac4247e9f3")
                .unwrap()
                .try_into()
                .unwrap();
        assert_eq!(
            to_swapped_bytes32(&bytes_to_reverse).to_hex_string(Case::Lower),
            "f3e94742aca4b5ef85488dc37c06c3282295ffec960994b2c0d5ac2a25a95766",
            "Reversed bytes32 is wrong"
        );
    }
}
